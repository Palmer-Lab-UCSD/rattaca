# Rattaca rrBLUP fit, prediction, and simulation
#
# By: Robert Vogel
# Date: 2023-08-14


#' Predict trait values from genotype
#'
#' @description
#' Compute the quantitative trait from an animal's genotype and
#' provided parameters. Parameters are inferred from a reference
#' data set.
#'
#' @export
#'
#' @param genotypes ((n sample, q markers) array | matrix)
#'      sample genotypes encoded on the interval [-1, 1].  the
#'      elements that are not integers (i.e. (-1,0,1)) are assumed
#'      to have been appropriately impurted
#' @param u ((q markers,) vector | (q markers,1) matrix)
#'      estimated random effects parameters
#' @param intercept (double)
#'
#' @return ((n sample,) vector)
#'      trait predictions predictions
#
predict_lmm <- function(genotypes, u, intercept)
{
    if (!is.matrix(genotypes))
        genotypes <- matrix(genotypes,nrow=1,
                            ncol=length(genotypes))

    if (!is.matrix(u))
        u <- matrix(u, nrow=length(u), ncol=1)


    if (!is.vector(intercept))
        intercept <- as.vector(intercept)
    
    if (length(intercept) != 1 &&
        length(intercept) != dim(genotypes)[1])
        stop("Intercept should have length 1 or n_samples")

    if (dim(genotypes)[2] != dim(u)[1])
        stop("Matrix and vector dimensions are incompatible")

    tmp_predict <- drop(genotypes %*% u + intercept)

    names(tmp_predict) <- rownames(genotypes)

    return(tmp_predict)
}



# TODO: Specify trait values are residuals of fixed effects.
# In documentation specify that that we assume that
# covariates have been regressed out.  Consequently, the only
# fixed effect is the intercept term

#' Fit marker based rrBLUP to data
#'
#' @description
#' Validate input data, fit LMM to data with
#' rrBLUP::mixed.solve and, and compute goodness-of-fit
#' statistics.
#'
#' @export
#' @param trait ((n animals,) double vector) of trait
#'     values.
#' @param genotypes ((n animals, q markers) double matrix)
#'     of animal genotypes.  Markers are assume to take
#'     values (1, 0, -1, NA).  NA values for marker \eqn{j} are 
#'     assigned the mean genotype over all animals \eqn{i} for
#'     for which marker \eqn{i \neq j} and is not NA.
#'
#' @return out (list): contains elements generated by
#'     rrBLUP::mixed.solve and goodness-of-fit values computed
#'     by this function.
#' \itemize{
#'      \item{$u}
#'      {
#'          ((q markers,) array) BLUPs, marker effect
#'          sizes from rrBLUP::mixed.solve
#'      }
#'      \item{$u.SE}
#'      {
#'          ((q markers,) array) standard error of 
#'          BLUPs produced by rrBLUP::mixed.solve
#'      }
#'      \item{$beta}
#'      {
#'          (double) intercept (BLUE) inferred by 
#'          rrBLUP::mixed.solve
#'      }
#'      \item{$beta.SE}
#'      {
#'          (double) standard error of intercept
#'          produced by rrBLUP::mixed.solve
#'      }
#'      \item{$LL}
#'      {
#'          (double) negative log-likelihood produced
#'          by rrBLUP::mixed.solve
#'      }
#'      \item{$Ve}
#'      {
#'          (double) variance of the error term
#'          produced by rrBLUP::mixed.solve
#'      }
#'      \item{$Vu}
#'      {
#'          (double) variance contribution of a single
#'          random effects term produced by rrBLUP::mixed.solve
#'      }
#'      \item{$r_sq}{(double) coefficient of determination}
#'      \item{$pearson_corr}{(double)}
#'      \item{$spearman_corr}{(double)}
#' }
#
fit <- function(trait, genotypes)
{
    # check data
    if (any(is.na(trait)) || any(is.na(genotypes)))
        stop("Data contains NA values, check validity")

    if (!is_genotype(genotypes))
        stop("Not genotype data")


    # TODO: check that row names match?
    out <- rrBLUP::mixed.solve(trait,
                               Z = genotypes,
                               SE = TRUE)

    tmp_predict <- predict_lmm(genotypes,
                           out$u,
                           out$beta)


    # goodness-of-fit measures
    out[["r_sq"]] <- compute_r_sq(trait, tmp_predict)
    out[["pearson_corr"]] <- stats::cor(trait, tmp_predict,
                                 method="pearson")
    out[["spearman_corr"]] <- stats::cor(trait, tmp_predict,,
                                  method="spearman")

    return(out)
}


get_n_samples <- function(dims)
    return(ifelse(is.null(dims), 1, dims[1]))


#' Generate an LMM simulation closure for a trait
#'
#' @description
#' Given the parameters of the LMM return a function to
#' generate independent samples from a given genotype matrix.
#'
#' @export
#'
#' @param intercept (double) 
#' @param u ((q markers,) vector) 
#'      vector of BLUPs, that is the expected value of the
#'      random marker effect sizes
#' @param sd_error (double)
#'      standard deviation of the model error.
#' @param int_se (NULL | double)
#'      standard deviation of the LMM random error term.
#' @param u_se (NULL | (q_markers,) vector)
#'      of standard error of the BLUPs
#'
#' @return (function)
#'      for generating samples from genotypes under the 
#'      rrBLUP LMM
#
gen_trait_sim_closure <- function(intercept, u, sd_error,
                                  intercept_se=NULL, u_se=NULL)
{

    q_markers <- length(u)

    if(is.null(u_se) && is.null(intercept_se))
    {
        # simulate:
        #   random error

        return(function(genotypes)
        {

            n_samples <- get_n_samples(dim(genotypes))

            return(predict_lmm(genotypes, u, intercept)
                 + stats::rnorm(n_samples,
                                0,
                                sd=sd_error))
        })

    } else if (is.null(u_se) && length(intercept_se) == 1) {

        # simulate:
        #   random error
        #   uncertainty in intercept inference

        return(function(genotypes)
        {
            n_samples <- get_n_samples(dim(genotypes))

            return(predict_lmm(genotypes,
                               u,
                               stats::rnorm(1, intercept,
                                            sd=intercept_se))
                 + stats::rnorm(n_samples,
                                0,
                                sd=sd_error))
        })

    } else if(length(u) == length(u_se) && is.null(intercept_se)) {

        # simulate:
        #   random error
        #   uncertainty in BLUPs

        return(function(genotypes)
        {
            n_samples <- get_n_samples(dim(genotypes))

            # TODO check whether this is correct
            #
            # genetic effects.  I think that under an assumption of
            # independence we need to sample the BLUPs independently,
            # for each sample
            trait <- apply(genotypes,
                           1,
                           predict_lmm,
                           stats::rnorm(q_markers, u, sd=u_se),
                           intercept)

            # return the genetic effects plus error
            return(trait
                + stats::rnorm(get_n_samples(dim(genotypes)),
                               0,
                               sd=sd_error))
        })

    } else if (length(u) == length(u_se)
               && length(intercept_se) == 1) {

        # simulate:
        #   random error
        #   uncertainty in BLUPs

        return(function(genotypes)
        {
            n_samples <- get_n_samples(dim(genotypes))

            # TODO check whether this is correct
            #
            # genetic effects.  I think that under an assumption of
            # independence we need to sample the BLUPs independently,
            # for each sample.  Sample unique intercepts per sample
            trait <- apply(genotypes,
                           1,
                           predict_lmm,
                           stats::rnorm(q_markers, u, sd=u_se),
                           stats::rnorm(1, intercept, sd=intercept_se))

            # return the genetic effects plus error
            return(trait
                + stats::rnorm(get_n_samples(dim(genotypes)),
                               0,
                               sd=sd_error))
        })
    }

    # if the inputs do not match the expected arguments, raise error
    stop("Wrong input")
}


#' Generate an LMM simulation closure from the r_sq
#'
#' @export
#'
#' @param r_sq (float [0,1))
#'      the coefficient of determination, a value 0 <= r_sq <  1
#'      exclusive, between genetics and the simulated trait
#'      measurements under the linear mixed model
#' @param genotypes ((n_samples, q_markers) matrix)
#'      genotype values
#' @param var_u (float (>0))
#'      the variance of the random effects
#' @param intercept (float)
#'      the intercept of the model
#'
#' @return (function)
#
gen_sim_closure_r_sq <- function(r_sq, genotypes,
                                 var_u=1, intercept=0)
{

    if (r_sq >= 1 || r_sq < 0)
        stop("r^2 must be on interval [0,1)")

    if (var_u < 0 || (var_u == 0 && r_sq != 0))
        stop("var_u must be > 0, unless r_sq = 0")

    if (!is.matrix(genotypes) || !is_genotype(genotypes))
        stop("genotypes must be a valid genotype matrix")

    n_samples <- dim(genotypes)[1]
    q_markers <- dim(genotypes)[2]

    if (r_sq == 0)
    {
        # When the r_sq is 0, then the variance of the trait
        # that is attributed to genetics is zero, therefore
        # the variance of the random effects is zero.  I set
        # all values u to zero.  In this case I use a default
        # error variance of 1
        return(gen_trait_sim_closure(intercept,
                                     rep(0, q_markers),
                                     1))
    }

    # The equation for var_error is derived from the definition
    # of r_sq and the statistical properties of the LMM, see
    # description for details.
    u <- matrix(stats::rnorm(q_markers, 0, sqrt(var_u)),
                nrow=q_markers,
                ncol=1)

    omega <- genotypes %*% u
    omega <- drop(t(omega) %*% omega) / n_samples
    var_error <- omega * (1 - r_sq) / r_sq

    return(gen_trait_sim_closure(intercept,
                         u,
                         sqrt(var_error)))
}


#' Predict phenotypes in a test dataset with known trait values using 
#' parameters from a previously fit model, and assess model performance
#'
#' @export
#'
#' @param phenotypes (numeric)
#'      A named vector of observed phenotype values for a single trait
#' @param genotypes (matrix)
#'      A matrix of m samples by n SNPs, with samples in the same
#'      order as phenotypes
#' @param fitted_u (numeric)
#'      A vector of marker effects from a fitted model
#' @param fitted_beta (numeric)
#'      The intercept term from a fitted model
#' 
#' @return A list of (1) trait observations from the test set,
#'      (2) trait predictions for the test set, and (3,4,5)
#'      model performance metrics on the test set  
#
validate_test_preds <- function(phenotypes,
                           genotypes, 
                           fitted_u,         
                           fitted_beta) 
{
    
    if (!identical(rownames(genotypes),names(phenotypes)))
        stop("Genotype and phenotype data are not properly aligned")
                   

    # predict on the test set using u, beta from the trained model
    test_pred <- predict_lmm(genotypes, fitted_u, fitted_beta)
 
    # goodness-of-fit measures
    rho <- cor(test_pred, phenotypes, method='spearman')
    r <- cor(test_pred, phenotypes, method='pearson')
    r_sq <- compute_r_sq(test_pred, phenotypes)
    
    out <- list(obs = phenotypes, pred = test_pred, r_sq = r_sq, pearson_corr = r, spearman_corr = rho)
    return(out)

}
