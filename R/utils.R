# Utility functions for RATTACA
#
# Author: Robert Vogel
# Date: 2023-08-20
#   
# Contributors:
#   
#

#' Test whether a matrix consists of genotype data
#'
#' @description
#' Valid genotype matrices should contain values in the
#' set \eqn{\{1,0,-1\}} if no imputation performed.  Otherwise,
#' genotype values \eqn{g_{ij} \in [-1, 1]}.
#'
#' @export
#'
#' @param x ((n, m) array | vector | matrix) of genotype
#'      values
#' @param imputed_vals (boolean) whether input contains
#'      imputed values
#'
#' @return (boolean)
#
is_genotype <- function(x, imputed_vals=TRUE)
{

    if (imputed_vals)
        return(all(x <= 1) && all(x >= -1))        

    return(length(setdiff(x, c(1, 0, -1))) == 0)
}


#' Load plink genotypes and perform mean imputation
#'
#' @export
#' 
#' @param prefix_name (character)
#'      prefix of plink bim, bed, and fam files that will be loaded
#'
#' @return ((n sample, q markers) matrix)
#'      of genotype values
load_and_prepare_plink_data <- function(prefix_name)
{
    # the genotype matrix with q marker rows and
    # n sample columns
    genotypes <- genio::read_plink(prefix_name)$X - 1

    return(impute(genotypes))
}


#' load trait data from csv and prepare
#'
#' @description
#'      Data are loaded assuming a header exists.  Using this 
#'      header, the row names are set to the sample id's and
#'      and samples with trait value equal to NA are removed.
#'
#' @export
#'
#' @param filename (character)
#'      path to trait csv table
#' @param col_to_rownames (character)
#'      name of column whose values will be the row index names
#' @param trait_name (character)
#'      name of column whose values consists of noramlized
#'      trait measurements
#' 
#' @return ((n sample, 1) dataframe)
#'      row names are sample id's, column lone column are 
#
load_and_prepare_trait_data <- function(filename,
                                        col_to_rownames,
                                        trait_name)
{
    data <- utils::read.csv(filename)[,c(col_to_rownames,
                                         trait_name)]

    data <- data[!is.na(data[,trait_name]), ]

    rownames(data) <- data[, col_to_rownames]
    data[,col_to_rownames] <- NULL

    return(data)
}


# TODO add arg type

#' Specify command line argument values
#'
#' @export
#'
#' @param default_val (NULL | interger | double | string)
#'      (default NULL)
#' @param help (string)
#'      (default NULL) documentation to be printed with --help
#' @param required (bool) 
#'      (default TRUE) whether the argument is required input
#'
#' @return (list) with correct key value pairs for parsing
#
argument <- function(default_val=NULL,
                     help=NULL,
                     required=TRUE, type="character")
{

    if (is.null(default_val) || storage.mode(default_val) == type)
        return(list(val=default_val, help=help,
                    type=type, required=required))

    stop("Default value doesn't match specified type")
}


# TODO add type checking of argument inputs
# TODO add required specification

#' Parse command line arguments
#'
#' @export
#'
#' @param ... ((character) key = (list) value) pairs where
#'      keys are command line options (including -- prefix) in
#'      quotes, and value is a list generated by rattaca::arg
#' @param description (character)
#'
#' @return (list) ((character) key = (object)  value) from
#'      option defaults of specified values from the command
#'      line
#
argument_parser <- function(..., description=NULL)
{

    arg_defs <- list(...)

    parse_arguments <- function(args)
    {

        # Should we print help?
        if ("--help" %in% args)
        {

            if (!is.null(description))
                cat(sprintf("%s\n\n", description))
            
            # TODO: need a better strategy for formatting
            # argument help entries
            cat(sprintf("%s\n", "Arguments"))

            for (a in names(arg_defs))
            {
                cat(sprintf("%s\t%s\n", a, arg_defs[[a]]$help))
            }
            
            return(NULL)
        }

        
        # Count the number of required inputs, this number will
        # validate whether all required inputs are given
        num_required <- 0
        for (key in names(arg_defs))
        {
            if (arg_defs[[key]]$required)
                num_required <- num_required + 1
        }

        # instantiate output list
        arg_out <- sapply(names(arg_defs),
                          function(x){arg_defs[[x]]$val})


        # parser input arguments vector
        i <- 1
        while (i <= length(args))
        {

            # inputs that are not specified raise exception

            if (!(args[i] %in% names(arg_defs)))
            {
                stop("Invalid option, see --help for options")
            } else if (arg_defs[[args[i]]]$required) {
                num_required <- num_required - 1
            }

            tmp_key <- args[i]
            tmp_val <- args[i+1]

            storage.mode(tmp_val) <- arg_defs[[tmp_key]]$type

            arg_out[[tmp_key]] <- tmp_val
            i <- i + 2
        }

        if (num_required != 0)
            stop("All required inputs not specified")

        return(arg_out)
    }

    return(parse_arguments)
}


# TO DO: when processing multiple traits, exclude any rows 
# that have NAs for all traits

#' Save a Plink-formatted file listing all samples phenotyped
#' for one or all traits in a dataset.
#'
#' @export
#'
#' @param phenotype_data (string)
#'      File path to a csv file containing one named column of 
#'      sample IDs and one or more named columns with phenotype
#'      data.
#' 
#' @param id_column (string)
#'      Text string with the header for the column containing
#'      sample IDs.
#' 
#' @param trait_column (string)
#'      (default NULL) Text string with the header for the desired
#'      phenotype, if only processing one. If NULL, all non-ID
#'      columns in the file will be processed. 
#' @param output_dir (string)
#'      The directory in which the Plink-formatted IDs file will be 
#'      saved.
#'
#' @return A list containing (1) the file path to the Plink-formatted 
#'      IDs file and (2) a vector of phenotyped IDs.
#
get_phenotyped_ids <- function(phenotype_data, id_column, trait_column = NULL, output_dir) {

    pheno_dat <- read.csv(phenotype_data)

    if (is.null(trait_column)) {
    
        phtyped_ids_file <- paste0(output_dir, '/phtyped_ids_all')
    
        write.table(data.frame(fam = 0, id = pheno_dat[[id_column]]), 
                phtyped_ids_file, sep='\t', row.names=F, col.names=F, quote=F)

        return(list(ids_file = phtyped_ids_file, ids = as.character(pheno_dat[[id_column]])))

    } else {
    
        trait <- trait_column
        phtyped_ids_file <- paste0(output_dir, '/phtyped_ids_', trait)
    
        trait_dat <- pheno_dat[[trait]]
        names(trait_dat) <- pheno_dat[[id_column]]
        trait_dat <- trait_dat[!is.na(trait_dat)]
        
        write.table(data.frame(fam = 0, id = names(trait_dat)), 
                phtyped_ids_file, sep='\t', row.names=F, col.names=F, quote=F)

        return(list(ids_file = phtyped_ids_file, ids = as.character(names(trait_dat))))

        
    }
}



#' Modify a Plink genotype dataset to produce a new Plink dataset
#' of system files, with option to read data into R
#'
#' @export
#'
#' @param input_genotypes (string)
#'      prefix of plink bim, bed, and fam files that will be
#'      loaded and modified
#' @param output_dir (string)
#'      Output directory in which to save the new Plink dataset
#' @param outfile_prefix (string) 
#'      (default '') The base file name for new Plink files.
#'      This will be appended with modifications to the original 
#'      dataset.
#' @param samples_to_keep (string) 
#'      (default NULL) If subsetting samples from the original
#'      dataset, the path to the file listing all samples desired
#'      for the new dataset. Must be in Plink .fam format, with 
#'      one row per sample and two columns: one column of family IDs 
#'      (or zeros), and one column of individual IDs, as produced
#'      by get_phenotyped_ids(). Using this option calls the Plink
#'      option '--keep'.
#' @param snps_to_keep (string) 
#'      (default NULL) If subsetting SNP variants from the original
#'      dataset, the path to the file listing all SNP variants desired
#'      for the new dataset. Must be formatted with one column of 
#'      variant IDs, one row per variant, as produced by either 
#'      sample_snps() or sample_snps_from_plink_files(). Using this 
#'      option calls the Plink option '--extract'.
#' @param maf_cutoff (double) 
#'      (default NULL) The desired minor allele frequency cutoff. All 
#'      variants with allele frequency in the original dataset below 
#'      the provided threshold will be excluded from the new dataset.
#'      Using this option calls the Plink option '--maf'.
#' @param missing_cutoff (double) 
#'      (default NULL) The desired missing call rate cutoff. All variants 
#'      with missing call rates exceeding the provided threshold in the 
#'      original dataset will be excluded from the new dataset. Using 
#'      this option calls the Plink option '--geno'.
#' @param hwe_cutoff (double) 
#'      (default NULL) The desired cutoff for Hardy-Weinberg exact test 
#'      P-values. All variants in the original dataset whose P-values 
#'      following a Hardy-Weinberg equilibrium exact test fall below the 
#'      provided threshold will be excluded from the new dataset. Using
#'      this option calls the Plink option '--hwe'.
#' @param ld_prune (bool) 
#'      (default FALSE) Whether or not to prune variants from the original
#'      dataset based on linkage disequilibrium with other variants. Using
#'      this option calls the Plink option '--indep-pairwise'.
#' @param ld_r2 (double) 
#'      (default NULL) If LD-pruning, The desired pairwise r^2 threshold.
#'      For all variant pairs within a desired window size, if the r^2
#'      of the pairwise correlation between variant allele counts exceeds
#'      this threshold, only one variant will be kept in the new dataset.
#' @param ld_window_size (integer) 
#'      (default NULL) If LD-pruning, the desired window size (in variant 
#'      count) in which to estimate pairwise linkage disequilibrium.
#' @param ld_step_size (integer) 
#'      (default NULL) If LD-pruning, the desired step size (in variant 
#'      count) by which the pruning window will slide before estimating 
#'      pairwise LD again.
#' @param return_data (bool) 
#'      (default TRUE) Whether or not to return the new dataset in the R 
#'      environment. If TRUE, returns a list containing (1) the file 
#'      path to the new dataset and (2) the new genotype matrix. If 
#'      FALSE, returns only the file directory. This option is preferable 
#'      when producing large datasets that become computationally intractable 
#'      to process within R.
#'
#' @return A list containing (1) the file path to the new dataset and 
#'      (2) the new genotype matrix.
#
make_plink_dataset <- function(input_genotypes,       
                               output_dir,            
                               outfile_prefix = '',   
                               samples_to_keep = NULL,
                               snps_to_keep = NULL,   
                               maf_cutoff = NULL,     
                               missing_cutoff = NULL, 
                               hwe_cutoff = NULL,     
                               ld_prune = FALSE,      
                               ld_r2 = NULL,          
                               ld_window_size = NULL, 
                               ld_step_size = NULL,   
                               return_data=TRUE)      
{
    
    # common arguments
    args <- c('-bfile', input_genotypes, '-make-bed')
    
    # set extra arguments based on user input
    
    # samples to keep
    if (!is.null(samples_to_keep)) {
        n_samples <- length(readLines(samples_to_keep))
        args <- c(args, '--keep', samples_to_keep)
        outfile_prefix <- paste0(outfile_prefix, '_n', n_samples)
    }
    # minor allele frequency cutoff
    if (!is.null(maf_cutoff)) {
        args <- c(args, '--maf', maf_cutoff)
        outfile_prefix <- paste0(outfile_prefix, '_maf', maf_cutoff)
    }
    
    # genotype missingness cutoff
    if (!is.null(missing_cutoff)) {
        args <- c(args, '--geno', missing_cutoff)
        outfile_prefix <- paste0(outfile_prefix, '_missing', missing_cutoff)
    }
    
    # HWE cutoff
    if (!is.null(hwe_cutoff)) {
        args <- c(args, '--hwe', hwe_cutoff)
        hwe_pval <- -log10(hwe_cutoff)
        outfile_prefix <- paste0(outfile_prefix, '_hwe', hwe_pval)
    }

    # SNP sampling
    if (!is.null(snps_to_keep)) {
        args <- c(args, '--extract', snps_to_keep)
        snp_n <- length(readLines(snps_to_keep)) / 1000
        outfile_prefix <- paste0(outfile_prefix, '_', snp_n, 'k_snps')
    }

    # LD pruning
    if (ld_prune) {
        
        if( is.null(ld_r2) | is.null(ld_window_size) | is.null(ld_step_size) ) {
            stop('Please provide LD-pruning parameters: r^2, window size, and step size')
        }
        
        args <- c(args, '--indep-pairwise', ld_window_size, ld_step_size, ld_r2)
        outfile_prefix <- paste(outfile_prefix, 'ldprune', ld_r2, ld_window_size, ld_step_size, sep='_')
    }
    
    # set plink arguments
    plink_file_name <- paste0(output_dir, '/', outfile_prefix)
    args <- c(args, '--out', plink_file_name)

    # print the plink call to the user
    print(paste('Plink call:', plink2, paste(args, collapse=' ')))

    # run plink
    system2(plink2, args)
    
    if (return_data){
    
        # read in plink genotypes and replace NA values
        plink_dat <- load_and_prepare_plink_data(plink_file_name)
        out <- list(geno_file = plink_file_name, geno = plink_dat)

    } else {
        out <- list(geno_file = plink_file_name, geno = NULL)
    }
    
    return(out)
}


#' Identify the set of SNP variants common to both the training
#' and test datasets
#'
#' @export
#'
#' @param train_genotypes (string)
#'      The file path/prefix for the training Plink dataset.
#' 
#' @param test_genotypes (string)
#'      The file path/prefix for the test Plink dataset.
#'
#' @return A vector of all SNP variants found in both datasets.
#
get_common_snpset <- function(train_genotypes, test_genotypes) {

    # read in snp sets
    all_train_snps <- genio::read_bim(paste0(train_genotypes, '.bim'))
    all_train_snps <- all_train_snps$id
    all_test_snps <- genio::read_bim(paste0(test_genotypes, '.bim'))
    all_test_snps <- all_test_snps$id
    
    # save all snps common to train/test sets from which to sample a common set of snps
    all_snps <- intersect(all_test_snps, all_train_snps)
    
    return(all_snps)
}


#' Produce one or multiple sets of SNPs randomly sampled
#' from an input SNP set
#'
#' @export
#'
#' @param input_snps (character)
#'      A vector of SNP variant names from which to sample. Names must be
#'      in format 'chromosome:position', e.g. 1:2456462
#' 
#' @param keep (int)
#'      (default 50000) The number of SNPs to keep
#'
#' @param iterations (int)
#'      (default 1) The number of random samples to produce      
#'
#' @param save_file (bool)
#'      (default FALSE) Whether or not to save the SNP sample(s) to file(s)
#'
#' @param output_dir (character)
#'      The output directory in which to save the SNP sample(s)
#'
#' @return A vector of all SNP variants found in both datasets.
#
sample_snps <- function(input_snps,
                        keep = 50000,
                        iterations = 1,
                        save_file = FALSE,
                        output_dir = NULL){
    
    # ensure inputs/outputs are provided if files are desired
    if (save_file) {
        if (is.null(output_dir)){
            stop('Include an output directory in which to save your file(s)')
        }
    }
    
    # list to store SNP samples
    snp_list <- list()
    
    n_k <- paste0(keep/1000,'k')
    max_i_figs <- nchar(iterations)

    for (i in 1:iterations){
                
        # sample SNPs, save SNPs to a dataframe
        use_snps <- sample(input_snps, keep)
        use_snps <- strsplit(use_snps,':')
        chr <- sapply(use_snps, function(x) x[1])
        pos <- sapply(use_snps, function(x) x[2])
        snp_df <- data.frame(cbind(chr,pos))
        snp_df$pos <- as.numeric(snp_df$pos)
        extra_chrs <- c('MT', 'X', 'Y')
        snp_num <- snp_df[!snp_df$chr %in% extra_chrs,]
        snp_char <- snp_df[snp_df$chr %in% extra_chrs,]
        snp_num$chr <- as.numeric(snp_num$chr)
        snp_char$chr <- as.character(snp_char$chr)
        snp_num <- snp_num[order(snp_num$chr, snp_num$pos),]
        snp_char <- snp_char[order(snp_char$chr, snp_char$pos),]
        snp_df <- rbind(snp_num, snp_char)
        use_snps <- paste0(snp_df$chr, ':', snp_df$pos)

        snp_list[[i]] <- use_snps
    
        if (save_file){
            
            i_figs <- nchar(i)
            rep_0s <- paste0(rep(0, max_i_figs - i_figs),collapse='')
            write.table(use_snps, paste0(output_dir, '/snpset_', n_k, '_random_', rep_0s, i), 
                        quote=F, row.names=F, col.names=F)    
        }

    }

    return(snp_list)          
}


#' Produce one or multiple sets of SNPs randomly sampled from an input
#' SNP set read in from Plink files, then use the new sample(s) to produce
#' a new Plink dataset(s)
#'
#' @export
#'
#' @param input_genotypes (character)
#'      The path/prefix of Plink files from which to sample SNPs
#' 
#' @param snp_directory (character)
#'      The directory in which to save the file(s) listing sampled SNPs
#'
#' @param output_dir (character)
#'      The output directory in which to save the new Plink dataset(s)  
#'
#' @param n_samples (int)
#'      (default 1) The number of random samples and Plink datasets 
#'      to produce
#'
#' @param keep_files (bool)
#'      (default TRUE) Whether or not to keep Plink genotype files.
#'      Use FALSE if only SNP files are desired
#'
#' @return A list of length n_samples of genotype datasets as produced
#'          by make_plink_dataset()
#
sample_snps_from_plink_files <- function(input_genotypes,   # genotype data in plink format: base filename
                                         snp_directory,     # directory of 1 or more txt files listing sampled SNPs
                                         output_dir,        # directory to hold the new datasets
                                         n_samples = 1,     # number of SNP samples to extract & datasets to produce
                                         keep_files = TRUE) # T: keep plink files; F: delete plink files
{
    input_filename <- basename(input_genotypes)
    all_samples <- list.files(snp_directory, full.names=T)
    geno_datasets <- list()
    
    for (i in 1:n_samples) {
        
        snp_sample <- all_samples[i]
        
        geno_datasets[[i]] <- make_plink_dataset(
            input_genotypes = input_genotypes,
            output_dir = output_dir,             # directory for the new dataset
            outfile_prefix = paste0(input_filename, '_', i),    # base filename for the new dataset
            snps_to_keep = snp_sample,    # text file of snps to keep from the input dataset
            return_data=TRUE)       # T: return the dataset in R; F: just produce the data files

        # delete unwanted files
        if (!keep_files) {
            
            system_call <- paste0('rm', ' ', geno_datasets[[i]]$geno_file, '.*')
            system(system_call)
            print(paste('System call:', system_call))
        }
    }
    
    return(geno_datasets)
}


#' Align genotype and phenotype datasets for prediction. Keeps only
#' samples that are shared between datasets, maintaining the same order
#' of sample IDs in both
#'
#' @export
#'
#' @param genotypes (list)
#'      A genotype dataset as produced by make_plink_dataset() or
#'      sample_snps_from_plink_files(): a list with elements $geno_file
#'      (the path/prefix to the Plink dataset) and $geno (a genotype matrix
#'      of n samples x q variants)
#' 
#' @param phenotypes (numeric)
#'      A named numeric vector of phenotype measurements
#'
#' @return A list of (1) the trait name, (2) all sample IDs shared between
#'      datasets, (3) the path/prefix for the Plink dataset used in
#'      alignment, (4) the aligned genotype matrix, and (5) the aligned
#'      phenotype data
#
align_data <- function(genotypes,  # matrix: n samples x q variants
                       phenotypes)#, # df w/ row names: samples x 1 trait, output from load_and_prepare_trait_data()
{
    
    geno_file <- genotypes$geno_file
    geno <- genotypes$geno
        
    # align genotype and phenotype data for prediction
    rat_ids <- intersect(rownames(geno), rownames(phenotypes))
    geno <- geno[rat_ids,]
    trait_dat <- phenotypes[rat_ids,]
    names(trait_dat) <- rat_ids

    out <- list(trait = trait, ids = rat_ids, geno_file = geno_file, geno = geno, pheno = trait_dat)
    return(out)
} 


#' Format trait observations and predictions into a dataframe
#'
#' @export
#'
#' @param lst (list)
#'      A list with elements $obs (named trait observations) and $pred (trait
#'      predictions in the same order as $obs). Each element may itself be a 
#'      list of length k sets of observations or predictions, such as output
#'      by kfold_cv()
#' 
#' @return A dataframe of all IDs, observations, and predictions, concatenated
#'      across all k folds
#

format_obs_pred <- function(lst) # list with trait observations and predictions
{

    k <- numeric()
    rfids <- character()
    obs <- numeric()
    pred <- numeric()
    
    for (i in seq_along(lst)) {
    
        k <- c(k, rep(i, length(lst[[i]]$obs)))
        rfids <- c(rfids, names(lst[[i]]$obs))
        obs <- c(obs, lst[[i]]$obs)
        pred <- c(pred, lst[[i]]$pred)
    
    }
    
    df <- data.frame(kfold = k, rfid = rfids, obs = obs, pred = pred)
    return(df)
        
}
