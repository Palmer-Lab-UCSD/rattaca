# Utility functions for RATTACA
#
# Author: Robert Vogel
# Date: 2023-08-20
#   
# Contributors:
#   
#

#' Test whether a matrix consists of genotype data
#'
#' @description
#' Valid genotype matrices should contain values in the
#' set \eqn{\{1,0,-1\}} if no imputation performed.  Otherwise,
#' genotype values \eqn{g_{ij} \in [-1, 1]}.
#'
#' @export
#'
#' @param x ((n, m) array | vector | matrix) of genotype
#'      values
#' @param imputed_vals (boolean) whether input contains
#'      imputed values
#'
#' @return (boolean)
#
is_genotype <- function(x, imputed_vals=TRUE)
{

    if (imputed_vals)
        return(all(x <= 1) && all(x >= -1))        

    return(length(setdiff(x, c(1, 0, -1))) == 0)
}


#' Load plink genotypes and perform mean imputation
#'
#' @export
#' 
#' @param prefix_name (character)
#'      prefix of plink bim, bed, and fam files that will be loaded
#'
#' @return ((n sample, q markers) matrix)
#'      of genotype values
load_and_prepare_plink_data <- function(prefix_name)
{
    # the genotype matrix with q marker rows and
    # n sample columns
    genotypes <- genio::read_plink(prefix_name)$X - 1

    return(impute(genotypes))
}


#' load trait data from csv and prepare
#'
#' @description
#'      Data are loaded assuming a header exists.  Using this 
#'      header, the row names are set to the sample id's and
#'      and samples with trait value equal to NA are removed.
#'
#' @export
#'
#' @param filename (character)
#'      path to trait csv table
#' @param col_to_rownames (character)
#'      name of column whose values will be the row index names
#' @param trait_name (character)
#'      name of column whose values consists of noramlized
#'      trait measurements
#' 
#' @return ((n sample, 1) dataframe)
#'      row names are sample id's, column lone column are 
#
load_and_prepare_trait_data <- function(filename,
                                        col_to_rownames,
                                        trait_name)
{
    data <- utils::read.csv(filename)[,c(col_to_rownames,
                                         trait_name)]

    data <- data[!is.na(data[,trait_name]), ]

    rownames(data) <- data[, col_to_rownames]
    data[,col_to_rownames] <- NULL

    return(data)
}


# TODO add arg type

#' Specify command line argument values
#'
#' @export
#'
#' @param default_val (NULL | interger | double | string)
#'      (default NULL)
#' @param help (string)
#'      (default NULL) documentation to be printed with --help
#' @param required (bool) 
#'      (default TRUE) whether the argument is required input
#'
#' @return (list) with correct key value pairs for parsing
#
argument <- function(default_val=NULL,
                     help=NULL,
                     required=TRUE, type="character")
{

    if (is.null(default_val) || storage.mode(default_val) == type)
        return(list(val=default_val, help=help,
                    type=type, required=required))

    stop("Default value doesn't match specified type")
}


# TODO add type checking of argument inputs
# TODO add required specification

#' Parse command line arguments
#'
#' @export
#'
#' @param ... ((character) key = (list) value) pairs where
#'      keys are command line options (including -- prefix) in
#'      quotes, and value is a list generated by rattaca::arg
#' @param description (character)
#'
#' @return (list) ((character) key = (object)  value) from
#'      option defaults of specified values from the command
#'      line
#
argument_parser <- function(..., description=NULL)
{

    arg_defs <- list(...)

    parse_arguments <- function(args)
    {

        # Should we print help?
        if ("--help" %in% args)
        {

            if (!is.null(description))
                cat(sprintf("%s\n\n", description))
            
            # TODO: need a better strategy for formatting
            # argument help entries
            cat(sprintf("%s\n", "Arguments"))

            for (a in names(arg_defs))
            {
                cat(sprintf("%s\t%s\n", a, arg_defs[[a]]$help))
            }
            
            return(NULL)
        }

        
        # Count the number of required inputs, this number will
        # validate whether all required inputs are given
        num_required <- 0
        for (key in names(arg_defs))
        {
            if (arg_defs[[key]]$required)
                num_required <- num_required + 1
        }

        # instantiate output list
        arg_out <- sapply(names(arg_defs),
                          function(x){arg_defs[[x]]$val})


        # parser input arguments vector
        i <- 1
        while (i <= length(args))
        {

            # inputs that are not specified raise exception

            if (!(args[i] %in% names(arg_defs)))
            {
                stop("Invalid option, see --help for options")
            } else if (arg_defs[[args[i]]]$required) {
                num_required <- num_required - 1
            }

            tmp_key <- args[i]
            tmp_val <- args[i+1]

            storage.mode(tmp_val) <- arg_defs[[tmp_key]]$type

            arg_out[[tmp_key]] <- tmp_val
            i <- i + 2
        }

        if (num_required != 0)
            stop("All required inputs not specified")

        return(arg_out)
    }

    return(parse_arguments)
}


# TO DO: when processing multiple traits, exclude any rows 
# that have NAs for all traits

#' Save a Plink-formatted file listing all samples phenotyped
#' for one or all traits in a dataset.
#'
#' @export
#'
#' @param phenotype_data (string)
#'      File path to a csv file containing one named column of 
#'      sample IDs and one or more named columns with phenotype
#'      data.
#' 
#' @param id_column (string)
#'      Text string with the header for the column containing
#'      sample IDs.
#' 
#' @param trait_column (string)
#'      (default NULL) Text string with the header for the desired
#'      phenotype, if only processing one. If NULL, all non-ID
#'      columns in the file will be processed. 
#' @param output_dir (string)
#'      The directory in which the Plink-formatted IDs file will be 
#'      saved.
#'
#' @return A list containing (1) the file path to the Plink-formatted 
#'      IDs file and (2) a vector of phenotyped IDs.
#
get_phenotyped_ids <- function(phenotype_data, id_column, output_dir, trait_column = NULL) {

    pheno_dat <- read.csv(phenotype_data)

    if (is.null(trait_column)) {
    
        phtyped_ids_file <- file.path(output_dir, 'phtyped_ids_all')
    
        write.table(data.frame(fam = 0, id = pheno_dat[[id_column]]), 
                phtyped_ids_file, sep='\t', row.names=F, col.names=F, quote=F)

        return(list(ids_file = phtyped_ids_file, ids = as.character(pheno_dat[[id_column]])))

    } else {
    
        trait <- trait_column
        phtyped_ids_file <- file.path(output_dir, paste0('phtyped_ids_', trait))
    
        trait_dat <- pheno_dat[[trait]]
        names(trait_dat) <- pheno_dat[[id_column]]
        trait_dat <- trait_dat[!is.na(trait_dat)]
        
        write.table(data.frame(fam = 0, id = names(trait_dat)), 
                phtyped_ids_file, sep='\t', row.names=F, col.names=F, quote=F)

        return(list(ids_file = phtyped_ids_file, ids = as.character(names(trait_dat))))

        
    }
}
